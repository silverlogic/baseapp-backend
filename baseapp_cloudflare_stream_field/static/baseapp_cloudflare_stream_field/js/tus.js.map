{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "lib/browser/fileReader.js",
    "lib/browser/fileSignature.js",
    "lib/browser/httpStack.js",
    "lib/browser/index.js",
    "lib/browser/isReactNative.js",
    "lib/browser/sources/FileSource.js",
    "lib/browser/sources/StreamSource.js",
    "lib/browser/sources/isCordova.js",
    "lib/browser/sources/readAsByteArray.js",
    "lib/browser/uriToBlob.js",
    "lib/browser/urlStorage.js",
    "lib/error.js",
    "lib/logger.js",
    "lib/noopUrlStorage.js",
    "lib/upload.js",
    "lib/uuid.js",
    "node_modules/base64-js/index.js",
    "node_modules/browserify/node_modules/buffer/index.js",
    "node_modules/ieee754/index.js",
    "node_modules/js-base64/base64.js",
    "node_modules/querystringify/index.js",
    "node_modules/requires-port/index.js",
    "node_modules/url-parse/index.js"
  ],
  "names": [],
  "mappings": "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C,CAAC,QAAF,CAAW,EAAX,CAAP;EACD,CAJM,CAAP;AAKD;;;ACnBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "import isReactNative from './isReactNative.js'\nimport uriToBlob from './uriToBlob.js'\n\nimport FileSource from './sources/FileSource.js'\nimport StreamSource from './sources/StreamSource.js'\n\nexport default class FileReader {\n  openFile (input, chunkSize) {\n    // In React Native, when user selects a file, instead of a File or Blob,\n    // you usually get a file object {} with a uri property that contains\n    // a local path to the file. We use XMLHttpRequest to fetch\n    // the file blob, before uploading with tus.\n    if (isReactNative() && input && typeof input.uri !== 'undefined') {\n      return uriToBlob(input.uri)\n        .then((blob) => new FileSource(blob))\n        .catch((err) => {\n          throw new Error(`tus: cannot fetch \\`file.uri\\` as Blob, make sure the uri is correct and accessible. ${err}`)\n        })\n    }\n\n    // Since we emulate the Blob type in our tests (not all target browsers\n    // support it), we cannot use `instanceof` for testing whether the input value\n    // can be handled. Instead, we simply check is the slice() function and the\n    // size property are available.\n    if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {\n      return Promise.resolve(new FileSource(input))\n    }\n\n    if (typeof input.read === 'function') {\n      chunkSize = Number(chunkSize)\n      if (!Number.isFinite(chunkSize)) {\n        return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'))\n      }\n\n      return Promise.resolve(new StreamSource(input, chunkSize))\n    }\n\n    return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'))\n  }\n}\n",
    "import isReactNative from './isReactNative.js'\n\n// TODO: Differenciate between input types\n\n/**\n * Generate a fingerprint for a file which will be used the store the endpoint\n *\n * @param {File} file\n * @param {Object} options\n * @param {Function} callback\n */\nexport default function fingerprint (file, options) {\n  if (isReactNative()) {\n    return Promise.resolve(reactNativeFingerprint(file, options))\n  }\n\n  return Promise.resolve([\n    'tus-br',\n    file.name,\n    file.type,\n    file.size,\n    file.lastModified,\n    options.endpoint,\n  ].join('-'))\n}\n\nfunction reactNativeFingerprint (file, options) {\n  const exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : 'noexif'\n  return [\n    'tus-rn',\n    file.name || 'noname',\n    file.size || 'nosize',\n    exifHash,\n    options.endpoint,\n  ].join('/')\n}\n\nfunction hashCode (str) {\n  /* eslint-disable no-bitwise */\n  // from https://stackoverflow.com/a/8831937/151666\n  let hash = 0\n  if (str.length === 0) {\n    return hash\n  }\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + char\n    hash &= hash // Convert to 32bit integer\n  }\n  return hash\n}\n",
    "/* eslint-disable max-classes-per-file */\nexport default class XHRHttpStack {\n  createRequest (method, url) {\n    return new Request(method, url)\n  }\n\n  getName () {\n    return 'XHRHttpStack'\n  }\n}\n\nclass Request {\n  constructor (method, url) {\n    this._xhr = new XMLHttpRequest()\n    this._xhr.open(method, url, true)\n\n    this._method = method\n    this._url = url\n    this._headers = {}\n  }\n\n  getMethod () {\n    return this._method\n  }\n\n  getURL () {\n    return this._url\n  }\n\n  setHeader (header, value) {\n    this._xhr.setRequestHeader(header, value)\n    this._headers[header] = value\n  }\n\n  getHeader (header) {\n    return this._headers[header]\n  }\n\n  setProgressHandler (progressHandler) {\n    // Test support for progress events before attaching an event listener\n    if (!('upload' in this._xhr)) {\n      return\n    }\n\n    this._xhr.upload.onprogress = (e) => {\n      if (!e.lengthComputable) {\n        return\n      }\n\n      progressHandler(e.loaded)\n    }\n  }\n\n  send (body = null) {\n    return new Promise((resolve, reject) => {\n      this._xhr.onload = () => {\n        resolve(new Response(this._xhr))\n      }\n\n      this._xhr.onerror = (err) => {\n        reject(err)\n      }\n\n      this._xhr.send(body)\n    })\n  }\n\n  abort () {\n    this._xhr.abort()\n    return Promise.resolve()\n  }\n\n  getUnderlyingObject () {\n    return this._xhr\n  }\n}\n\nclass Response {\n  constructor (xhr) {\n    this._xhr = xhr\n  }\n\n  getStatus () {\n    return this._xhr.status\n  }\n\n  getHeader (header) {\n    return this._xhr.getResponseHeader(header)\n  }\n\n  getBody () {\n    return this._xhr.responseText\n  }\n\n  getUnderlyingObject () {\n    return this._xhr\n  }\n}\n",
    "import BaseUpload from '../upload.js'\nimport NoopUrlStorage from '../noopUrlStorage.js'\nimport { enableDebugLog } from '../logger.js'\nimport DetailedError from '../error.js'\n\nimport { canStoreURLs, WebStorageUrlStorage } from './urlStorage.js'\nimport DefaultHttpStack from './httpStack.js'\nimport FileReader from './fileReader.js'\nimport fingerprint from './fileSignature.js'\n\nconst defaultOptions = {\n  ...BaseUpload.defaultOptions,\n  httpStack : new DefaultHttpStack(),\n  fileReader: new FileReader(),\n  urlStorage: (canStoreURLs ? new WebStorageUrlStorage() : new NoopUrlStorage()),\n  fingerprint,\n}\n\nclass Upload extends BaseUpload {\n  constructor (file = null, options = {}) {\n    options = { ...defaultOptions, ...options }\n    super(file, options)\n  }\n\n  static terminate (url, options = {}) {\n    options = { ...defaultOptions, ...options }\n    return BaseUpload.terminate(url, options)\n  }\n}\n\nconst { XMLHttpRequest, Blob } = window\n\nconst isSupported = (\n  XMLHttpRequest\n  && Blob\n  && typeof Blob.prototype.slice === 'function'\n)\n\nexport {\n  Upload,\n  canStoreURLs,\n  defaultOptions,\n  isSupported,\n  enableDebugLog,\n  DefaultHttpStack,\n  DetailedError,\n}\n",
    "const isReactNative = () => (typeof navigator !== 'undefined'\n  && typeof navigator.product === 'string'\n  && navigator.product.toLowerCase() === 'reactnative')\n\nexport default isReactNative\n",
    "import isCordova from './isCordova.js'\nimport readAsByteArray from './readAsByteArray.js'\n\nexport default class FileSource {\n  // Make this.size a method\n  constructor (file) {\n    this._file = file\n    this.size = file.size\n  }\n\n  slice (start, end) {\n    // In Apache Cordova applications, a File must be resolved using\n    // FileReader instances, see\n    // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file\n    if (isCordova()) {\n      return readAsByteArray(this._file.slice(start, end))\n    }\n\n    const value = this._file.slice(start, end)\n    return Promise.resolve({ value })\n  }\n\n  close () {\n    // Nothing to do here since we don't need to release any resources.\n  }\n}\n",
    "function len (blobOrArray) {\n  if (blobOrArray === undefined) return 0\n  if (blobOrArray.size !== undefined) return blobOrArray.size\n  return blobOrArray.length\n}\n\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\nfunction concat (a, b) {\n  if (a.concat) { // Is `a` an Array?\n    return a.concat(b)\n  }\n  if (a instanceof Blob) {\n    return new Blob([a, b], { type: a.type })\n  }\n  if (a.set) { // Is `a` a typed array?\n    const c = new a.constructor(a.length + b.length)\n    c.set(a)\n    c.set(b, a.length)\n    return c\n  }\n  throw new Error('Unknown data type')\n}\n\nexport default class StreamSource {\n  constructor (reader) {\n    this._buffer = undefined\n    this._bufferOffset = 0\n    this._reader = reader\n    this._done = false\n  }\n\n  slice (start, end) {\n    if (start < this._bufferOffset) {\n      return Promise.reject(new Error(\"Requested data is before the reader's current offset\"))\n    }\n\n    return this._readUntilEnoughDataOrDone(start, end)\n  }\n\n  _readUntilEnoughDataOrDone (start, end) {\n    const hasEnoughData = end <= this._bufferOffset + len(this._buffer)\n    if (this._done || hasEnoughData) {\n      const value = this._getDataFromBuffer(start, end)\n      const done = value == null ? this._done : false\n      return Promise.resolve({ value, done })\n    }\n\n    return this._reader.read().then(({ value, done }) => {\n      if (done) {\n        this._done = true\n      } else if (this._buffer === undefined) {\n        this._buffer = value\n      } else {\n        this._buffer = concat(this._buffer, value)\n      }\n\n      return this._readUntilEnoughDataOrDone(start, end)\n    })\n  }\n\n  _getDataFromBuffer (start, end) {\n    // Remove data from buffer before `start`.\n    // Data might be reread from the buffer if an upload fails, so we can only\n    // safely delete data when it comes *before* what is currently being read.\n    if (start > this._bufferOffset) {\n      this._buffer = this._buffer.slice(start - this._bufferOffset)\n      this._bufferOffset = start\n    }\n    // If the buffer is empty after removing old data, all data has been read.\n    const hasAllDataBeenRead = len(this._buffer) === 0\n    if (this._done && hasAllDataBeenRead) {\n      return null\n    }\n    // We already removed data before `start`, so we just return the first\n    // chunk from the buffer.\n    return this._buffer.slice(0, end - start)\n  }\n\n  close () {\n    if (this._reader.cancel) {\n      this._reader.cancel()\n    }\n  }\n}\n",
    "const isCordova = () => typeof window !== 'undefined' && (\n  typeof window.PhoneGap !== 'undefined'\n    || typeof window.Cordova !== 'undefined'\n    || typeof window.cordova !== 'undefined')\n\nexport default isCordova\n",
    "/**\n * readAsByteArray converts a File object to a Uint8Array.\n * This function is only used on the Apache Cordova platform.\n * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file\n */\nexport default function readAsByteArray (chunk) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = () => {\n      const value = new Uint8Array(reader.result)\n      resolve({ value })\n    }\n    reader.onerror = (err) => {\n      reject(err)\n    }\n    reader.readAsArrayBuffer(chunk)\n  })\n}\n",
    "/**\n * uriToBlob resolves a URI to a Blob object. This is used for\n * React Native to retrieve a file (identified by a file://\n * URI) as a blob.\n */\nexport default function uriToBlob (uri) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.responseType = 'blob'\n    xhr.onload = () => {\n      const blob = xhr.response\n      resolve(blob)\n    }\n    xhr.onerror = (err) => {\n      reject(err)\n    }\n    xhr.open('GET', uri)\n    xhr.send()\n  })\n}\n",
    "let hasStorage = false\ntry {\n  hasStorage = 'localStorage' in window\n\n  // Attempt to store and read entries from the local storage to detect Private\n  // Mode on Safari on iOS (see #49)\n  const key = 'tusSupport'\n  localStorage.setItem(key, localStorage.getItem(key))\n} catch (e) {\n  // If we try to access localStorage inside a sandboxed iframe, a SecurityError\n  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is\n  // thrown (see #49)\n  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {\n    hasStorage = false\n  } else {\n    throw e\n  }\n}\n\nexport const canStoreURLs = hasStorage\n\nexport class WebStorageUrlStorage {\n  findAllUploads () {\n    const results = this._findEntries('tus::')\n    return Promise.resolve(results)\n  }\n\n  findUploadsByFingerprint (fingerprint) {\n    const results = this._findEntries(`tus::${fingerprint}::`)\n    return Promise.resolve(results)\n  }\n\n  removeUpload (urlStorageKey) {\n    localStorage.removeItem(urlStorageKey)\n    return Promise.resolve()\n  }\n\n  addUpload (fingerprint, upload) {\n    const id = Math.round(Math.random() * 1e12)\n    const key = `tus::${fingerprint}::${id}`\n\n    localStorage.setItem(key, JSON.stringify(upload))\n    return Promise.resolve(key)\n  }\n\n  _findEntries (prefix) {\n    const results = []\n\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i)\n      if (key.indexOf(prefix) !== 0) continue\n\n      try {\n        const upload = JSON.parse(localStorage.getItem(key))\n        upload.urlStorageKey = key\n\n        results.push(upload)\n      } catch (e) {\n        // The JSON parse error is intentionally ignored here, so a malformed\n        // entry in the storage cannot prevent an upload.\n      }\n    }\n\n    return results\n  }\n}\n",
    "class DetailedError extends Error {\n  constructor (message, causingErr = null, req = null, res = null) {\n    super(message)\n\n    this.originalRequest = req\n    this.originalResponse = res\n    this.causingError = causingErr\n\n    if (causingErr != null) {\n      message += `, caused by ${causingErr.toString()}`\n    }\n\n    if (req != null) {\n      const requestId = req.getHeader('X-Request-ID') || 'n/a'\n      const method = req.getMethod()\n      const url = req.getURL()\n      const status = res ? res.getStatus() : 'n/a'\n      const body = res ? (res.getBody() || '') : 'n/a'\n      message += `, originated from request (method: ${method}, url: ${url}, response code: ${status}, response text: ${body}, request id: ${requestId})`\n    }\n    this.message = message\n  }\n}\n\nexport default DetailedError\n",
    "/* eslint no-console: \"off\" */\n\nlet isEnabled = false\n\nexport function enableDebugLog () {\n  isEnabled = true\n}\n\nexport function log (msg) {\n  if (!isEnabled) return\n  console.log(msg)\n}\n",
    "/* eslint no-unused-vars: \"off\" */\n\nexport default class NoopUrlStorage {\n  listAllUploads () {\n    return Promise.resolve([])\n  }\n\n  findUploadsByFingerprint (fingerprint) {\n    return Promise.resolve([])\n  }\n\n  removeUpload (urlStorageKey) {\n    return Promise.resolve()\n  }\n\n  addUpload (fingerprint, upload) {\n    return Promise.resolve(null)\n  }\n}\n",
    "import { Base64 } from 'js-base64'\nimport URL from 'url-parse'\nimport DetailedError from './error.js'\nimport { log } from './logger.js'\nimport uuid from './uuid.js'\n\nconst defaultOptions = {\n  endpoint: null,\n\n  uploadUrl  : null,\n  metadata   : {},\n  fingerprint: null,\n  uploadSize : null,\n\n  onProgress           : null,\n  onChunkComplete      : null,\n  onSuccess            : null,\n  onError              : null,\n  _onUploadUrlAvailable: null,\n\n  overridePatchMethod: false,\n  headers            : {},\n  addRequestId       : false,\n  onBeforeRequest    : null,\n  onAfterResponse    : null,\n  onShouldRetry      : null,\n\n  chunkSize                  : Infinity,\n  retryDelays                : [0, 1000, 3000, 5000],\n  parallelUploads            : 1,\n  parallelUploadBoundaries   : null,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess : false,\n  uploadLengthDeferred       : false,\n  uploadDataDuringCreation   : false,\n\n  urlStorage: null,\n  fileReader: null,\n  httpStack : null,\n}\n\nclass BaseUpload {\n  constructor (file, options) {\n    // Warn about removed options from previous versions\n    if ('resume' in options) {\n      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.') // eslint-disable-line no-console\n    }\n\n    // The default options will already be added from the wrapper classes.\n    this.options = options\n\n    // Cast chunkSize to integer\n    this.options.chunkSize = Number(this.options.chunkSize)\n\n    // The storage module used to store URLs\n    this._urlStorage = this.options.urlStorage\n\n    // The underlying File/Blob object\n    this.file = file\n\n    // The URL against which the file will be uploaded\n    this.url = null\n\n    // The underlying request object for the current PATCH request\n    this._req = null\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null\n\n    // The key that the URL storage returned when saving an URL with a fingerprint,\n    this._urlStorageKey = null\n\n    // The offset used in the current PATCH request\n    this._offset = null\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false\n\n    // The file's size in bytes\n    this._size = null\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null\n\n    // The current count of attempts which have been made. Zero indicates none.\n    this._retryAttempt = 0\n\n    // The timeout's ID which is used to delay the next retry\n    this._retryTimeout = null\n\n    // The offset of the remote upload before the latest attempt was started.\n    this._offsetBeforeRetry = 0\n\n    // An array of BaseUpload instances which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n    this._parallelUploads = null\n\n    // An array of upload URLs which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n    this._parallelUploadUrls = null\n  }\n\n  /**\n   * Use the Termination extension to delete an upload from the server by sending a DELETE\n   * request to the specified upload URL. This is only possible if the server supports the\n   * Termination extension. If the `options.retryDelays` property is set, the method will\n   * also retry if an error ocurrs.\n   *\n   * @param {String} url The upload's URL which will be terminated.\n   * @param {object} options Optional options for influencing HTTP requests.\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n   */\n  static terminate (url, options = {}) {\n    const req = openRequest('DELETE', url, options)\n\n    return sendRequest(req, null, options).then((res) => {\n      // A 204 response indicates a successfull request\n      if (res.getStatus() === 204) {\n        return\n      }\n\n      throw new DetailedError('tus: unexpected response while terminating upload', null, req, res)\n    }).catch((err) => {\n      if (!(err instanceof DetailedError)) {\n        err = new DetailedError('tus: failed to terminate upload', err, req, null)\n      }\n\n      if (!shouldRetry(err, 0, options)) {\n        throw err\n      }\n\n      // Instead of keeping track of the retry attempts, we remove the first element from the delays\n      // array. If the array is empty, all retry attempts are used up and we will bubble up the error.\n      // We recursively call the terminate function will removing elements from the retryDelays array.\n      const delay = options.retryDelays[0]\n      const remainingDelays = options.retryDelays.slice(1)\n      const newOptions = {\n        ...options,\n        retryDelays: remainingDelays,\n      }\n      return new Promise((resolve) => setTimeout(resolve, delay))\n        .then(() => BaseUpload.terminate(url, newOptions))\n    })\n  }\n\n  findPreviousUploads () {\n    return this.options.fingerprint(this.file, this.options)\n      .then((fingerprint) => this._urlStorage.findUploadsByFingerprint(fingerprint))\n  }\n\n  resumeFromPreviousUpload (previousUpload) {\n    this.url = previousUpload.uploadUrl || null\n    this._parallelUploadUrls = previousUpload.parallelUploadUrls || null\n    this._urlStorageKey = previousUpload.urlStorageKey\n  }\n\n  start () {\n    const { file } = this\n\n    if (!file) {\n      this._emitError(new Error('tus: no file or stream to upload provided'))\n      return\n    }\n\n    if (!this.options.endpoint && !this.options.uploadUrl && !this.url) {\n      this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'))\n      return\n    }\n\n    const { retryDelays } = this.options\n    if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {\n      this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'))\n      return\n    }\n\n    if (this.options.parallelUploads > 1) {\n      // Test which options are incompatible with parallel uploads.\n      for (const optionName of ['uploadUrl', 'uploadSize', 'uploadLengthDeferred']) {\n        if (this.options[optionName]) {\n          this._emitError(new Error(`tus: cannot use the ${optionName} option when parallelUploads is enabled`))\n          return\n        }\n      }\n    }\n\n    if (this.options.parallelUploadBoundaries) {\n      if (this.options.parallelUploads <= 1) {\n        this._emitError(new Error('tus: cannot use the `parallelUploadBoundaries` option when `parallelUploads` is disabled'))\n        return\n      }\n      if (this.options.parallelUploads !== this.options.parallelUploadBoundaries.length) {\n        this._emitError(new Error('tus: the `parallelUploadBoundaries` must have the same length as the value of `parallelUploads`'))\n        return\n      }\n    }\n\n    this.options.fingerprint(file, this.options)\n      .then((fingerprint) => {\n        if (fingerprint == null) {\n          log('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.')\n        } else {\n          log(`Calculated fingerprint: ${fingerprint}`)\n        }\n\n        this._fingerprint = fingerprint\n\n        if (this._source) {\n          return this._source\n        }\n        return this.options.fileReader.openFile(file, this.options.chunkSize)\n      })\n      .then((source) => {\n        this._source = source\n\n        // First, we look at the uploadLengthDeferred option.\n        // Next, we check if the caller has supplied a manual upload size.\n        // Finally, we try to use the calculated size from the source object.\n        if (this.options.uploadLengthDeferred) {\n          this._size = null\n        } else if (this.options.uploadSize != null) {\n          this._size = Number(this.options.uploadSize)\n          if (Number.isNaN(this._size)) {\n            this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'))\n            return\n          }\n        } else {\n          this._size = this._source.size\n          if (this._size == null) {\n            this._emitError(new Error(\"tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option\"))\n            return\n          }\n        }\n\n        // If the upload was configured to use multiple requests or if we resume from\n        // an upload which used multiple requests, we start a parallel upload.\n        if (this.options.parallelUploads > 1 || this._parallelUploadUrls != null) {\n          this._startParallelUpload()\n        } else {\n          this._startSingleUpload()\n        }\n      })\n      .catch((err) => {\n        this._emitError(err)\n      })\n  }\n\n  /**\n   * Initiate the uploading procedure for a parallelized upload, where one file is split into\n   * multiple request which are run in parallel.\n   *\n   * @api private\n   */\n  _startParallelUpload () {\n    const totalSize = this._size\n    let totalProgress = 0\n    this._parallelUploads = []\n\n    const partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads\n\n    // The input file will be split into multiple slices which are uploaded in separate\n    // requests. Here we get the start and end position for the slices.\n    const parts = this.options.parallelUploadBoundaries ?? splitSizeIntoParts(this._source.size, partCount)\n\n    // Attach URLs from previous uploads, if available.\n    if (this._parallelUploadUrls) {\n      parts.forEach((part, index) => {\n        part.uploadUrl = this._parallelUploadUrls[index] || null\n      })\n    }\n\n    // Create an empty list for storing the upload URLs\n    this._parallelUploadUrls = new Array(parts.length)\n\n    // Generate a promise for each slice that will be resolve if the respective\n    // upload is completed.\n    const uploads = parts.map((part, index) => {\n      let lastPartProgress = 0\n\n      return this._source.slice(part.start, part.end)\n        .then(({ value }) => new Promise((resolve, reject) => {\n          // Merge with the user supplied options but overwrite some values.\n          const options = {\n            ...this.options,\n            // If available, the partial upload should be resumed from a previous URL.\n            uploadUrl                  : part.uploadUrl || null,\n            // We take manually care of resuming for partial uploads, so they should\n            // not be stored in the URL storage.\n            storeFingerprintForResuming: false,\n            removeFingerprintOnSuccess : false,\n            // Reset the parallelUploads option to not cause recursion.\n            parallelUploads            : 1,\n            // Reset this option as we are not doing a parallel upload.\n            parallelUploadBoundaries   : null,\n            metadata                   : {},\n            // Add the header to indicate the this is a partial upload.\n            headers                    : {\n              ...this.options.headers,\n              'Upload-Concat': 'partial',\n            },\n            // Reject or resolve the promise if the upload errors or completes.\n            onSuccess : resolve,\n            onError   : reject,\n            // Based in the progress for this partial upload, calculate the progress\n            // for the entire final upload.\n            onProgress: (newPartProgress) => {\n              totalProgress = totalProgress - lastPartProgress + newPartProgress\n              lastPartProgress = newPartProgress\n              this._emitProgress(totalProgress, totalSize)\n            },\n            // Wait until every partial upload has an upload URL, so we can add\n            // them to the URL storage.\n            _onUploadUrlAvailable: () => {\n              this._parallelUploadUrls[index] = upload.url\n              // Test if all uploads have received an URL\n              if (this._parallelUploadUrls.filter(u => Boolean(u)).length === parts.length) {\n                this._saveUploadInUrlStorage()\n              }\n            },\n          }\n\n          const upload = new BaseUpload(value, options)\n          upload.start()\n\n          // Store the upload in an array, so we can later abort them if necessary.\n          this._parallelUploads.push(upload)\n        }))\n    })\n\n    let req\n    // Wait until all partial uploads are finished and we can send the POST request for\n    // creating the final upload.\n    Promise.all(uploads).then(() => {\n      req = this._openRequest('POST', this.options.endpoint)\n      req.setHeader('Upload-Concat', `final;${this._parallelUploadUrls.join(' ')}`)\n\n      // Add metadata if values have been added\n      const metadata = encodeMetadata(this.options.metadata)\n      if (metadata !== '') {\n        req.setHeader('Upload-Metadata', metadata)\n      }\n\n      return this._sendRequest(req, null)\n    }).then((res) => {\n      if (!inStatusCategory(res.getStatus(), 200)) {\n        this._emitHttpError(req, res, 'tus: unexpected response while creating upload')\n        return\n      }\n\n      const location = res.getHeader('Location')\n      if (location == null) {\n        this._emitHttpError(req, res, 'tus: invalid or missing Location header')\n        return\n      }\n\n      this.url = resolveUrl(this.options.endpoint, location)\n      log(`Created upload at ${this.url}`)\n\n      this._emitSuccess()\n    }).catch((err) => {\n      this._emitError(err)\n    })\n  }\n\n  /**\n   * Initiate the uploading procedure for a non-parallel upload. Here the entire file is\n   * uploaded in a sequential matter.\n   *\n   * @api private\n   */\n  _startSingleUpload () {\n    // Reset the aborted flag when the upload is started or else the\n    // _performUpload will stop before sending a request if the upload has been\n    // aborted previously.\n    this._aborted = false\n\n    // The upload had been started previously and we should reuse this URL.\n    if (this.url != null) {\n      log(`Resuming upload from previous URL: ${this.url}`)\n      this._resumeUpload()\n      return\n    }\n\n    // A URL has manually been specified, so we try to resume\n    if (this.options.uploadUrl != null) {\n      log(`Resuming upload from provided URL: ${this.options.uploadUrl}`)\n      this.url = this.options.uploadUrl\n      this._resumeUpload()\n      return\n    }\n\n    // An upload has not started for the file yet, so we start a new one\n    log('Creating a new upload')\n    this._createUpload()\n  }\n\n  /**\n   * Abort any running request and stop the current upload. After abort is called, no event\n   * handler will be invoked anymore. You can use the `start` method to resume the upload\n   * again.\n   * If `shouldTerminate` is true, the `terminate` function will be called to remove the\n   * current upload from the server.\n   *\n   * @param {boolean} shouldTerminate True if the upload should be deleted from the server.\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n   */\n  abort (shouldTerminate) {\n    // Stop any parallel partial uploads, that have been started in _startParallelUploads.\n    if (this._parallelUploads != null) {\n      this._parallelUploads.forEach((upload) => {\n        upload.abort(shouldTerminate)\n      })\n    }\n\n    // Stop any current running request.\n    if (this._req !== null) {\n      this._req.abort()\n      // Note: We do not close the file source here, so the user can resume in the future.\n    }\n    this._aborted = true\n\n    // Stop any timeout used for initiating a retry.\n    if (this._retryTimeout != null) {\n      clearTimeout(this._retryTimeout)\n      this._retryTimeout = null\n    }\n\n    if (!shouldTerminate || this.url == null) {\n      return Promise.resolve()\n    }\n\n    return BaseUpload.terminate(this.url, this.options)\n      // Remove entry from the URL storage since the upload URL is no longer valid.\n      .then(() => this._removeFromUrlStorage())\n  }\n\n  _emitHttpError (req, res, message, causingErr) {\n    this._emitError(new DetailedError(message, causingErr, req, res))\n  }\n\n  _emitError (err) {\n    // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.\n    if (this._aborted) return\n\n    // Check if we should retry, when enabled, before sending the error to the user.\n    if (this.options.retryDelays != null) {\n      // We will reset the attempt counter if\n      // - we were already able to connect to the server (offset != null) and\n      // - we were able to upload a small chunk of data to the server\n      const shouldResetDelays = this._offset != null && (this._offset > this._offsetBeforeRetry)\n      if (shouldResetDelays) {\n        this._retryAttempt = 0\n      }\n\n      if (shouldRetry(err, this._retryAttempt, this.options)) {\n        const delay = this.options.retryDelays[this._retryAttempt++]\n\n        this._offsetBeforeRetry = this._offset\n\n        this._retryTimeout = setTimeout(() => {\n          this.start()\n        }, delay)\n        return\n      }\n    }\n\n    if (typeof this.options.onError === 'function') {\n      this.options.onError(err)\n    } else {\n      throw err\n    }\n  }\n\n  /**\n   * Publishes notification if the upload has been successfully completed.\n   *\n   * @api private\n   */\n  _emitSuccess () {\n    if (this.options.removeFingerprintOnSuccess) {\n      // Remove stored fingerprint and corresponding endpoint. This causes\n      // new uploads of the same file to be treated as a different file.\n      this._removeFromUrlStorage()\n    }\n\n    if (typeof this.options.onSuccess === 'function') {\n      this.options.onSuccess()\n    }\n  }\n\n  /**\n   * Publishes notification when data has been sent to the server. This\n   * data may not have been accepted by the server yet.\n   *\n   * @param {number} bytesSent  Number of bytes sent to the server.\n   * @param {number} bytesTotal Total number of bytes to be sent to the server.\n   * @api private\n   */\n  _emitProgress (bytesSent, bytesTotal) {\n    if (typeof this.options.onProgress === 'function') {\n      this.options.onProgress(bytesSent, bytesTotal)\n    }\n  }\n\n  /**\n   * Publishes notification when a chunk of data has been sent to the server\n   * and accepted by the server.\n   * @param {number} chunkSize  Size of the chunk that was accepted by the server.\n   * @param {number} bytesAccepted Total number of bytes that have been\n   *                                accepted by the server.\n   * @param {number} bytesTotal Total number of bytes to be sent to the server.\n   * @api private\n   */\n  _emitChunkComplete (chunkSize, bytesAccepted, bytesTotal) {\n    if (typeof this.options.onChunkComplete === 'function') {\n      this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal)\n    }\n  }\n\n  /**\n   * Create a new upload using the creation extension by sending a POST\n   * request to the endpoint. After successful creation the file will be\n   * uploaded\n   *\n   * @api private\n   */\n  _createUpload () {\n    if (!this.options.endpoint) {\n      this._emitError(new Error('tus: unable to create upload because no endpoint is provided'))\n      return\n    }\n\n    const req = this._openRequest('POST', this.options.endpoint)\n\n    if (this.options.uploadLengthDeferred) {\n      req.setHeader('Upload-Defer-Length', 1)\n    } else {\n      req.setHeader('Upload-Length', this._size)\n    }\n\n    // Add metadata if values have been added\n    const metadata = encodeMetadata(this.options.metadata)\n    if (metadata !== '') {\n      req.setHeader('Upload-Metadata', metadata)\n    }\n\n    let promise\n    if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n      this._offset = 0\n      promise = this._addChunkToRequest(req)\n    } else {\n      promise = this._sendRequest(req, null)\n    }\n\n    promise.then((res) => {\n      if (!inStatusCategory(res.getStatus(), 200)) {\n        this._emitHttpError(req, res, 'tus: unexpected response while creating upload')\n        return\n      }\n\n      const location = res.getHeader('Location')\n      if (location == null) {\n        this._emitHttpError(req, res, 'tus: invalid or missing Location header')\n        return\n      }\n\n      this.url = resolveUrl(this.options.endpoint, location)\n      log(`Created upload at ${this.url}`)\n\n      if (typeof this.options._onUploadUrlAvailable === 'function') {\n        this.options._onUploadUrlAvailable()\n      }\n\n      if (this._size === 0) {\n        // Nothing to upload and file was successfully created\n        this._emitSuccess()\n        this._source.close()\n        return\n      }\n\n      this._saveUploadInUrlStorage()\n        .then(() => {\n          if (this.options.uploadDataDuringCreation) {\n            this._handleUploadResponse(req, res)\n          } else {\n            this._offset = 0\n            this._performUpload()\n          }\n        })\n    }).catch((err) => {\n      this._emitHttpError(req, null, 'tus: failed to create upload', err)\n    })\n  }\n\n  /*\n   * Try to resume an existing upload. First a HEAD request will be sent\n   * to retrieve the offset. If the request fails a new upload will be\n   * created. In the case of a successful response the file will be uploaded.\n   *\n   * @api private\n   */\n  _resumeUpload () {\n    const req = this._openRequest('HEAD', this.url)\n    const promise = this._sendRequest(req, null)\n\n    promise.then((res) => {\n      const status = res.getStatus()\n      if (!inStatusCategory(status, 200)) {\n        // If the upload is locked (indicated by the 423 Locked status code), we\n        // emit an error instead of directly starting a new upload. This way the\n        // retry logic can catch the error and will retry the upload. An upload\n        // is usually locked for a short period of time and will be available\n        // afterwards.\n        if (status === 423) {\n          this._emitHttpError(req, res, 'tus: upload is currently locked; retry later')\n          return\n        }\n\n        if (inStatusCategory(status, 400)) {\n          // Remove stored fingerprint and corresponding endpoint,\n          // on client errors since the file can not be found\n          this._removeFromUrlStorage()\n        }\n\n        if (!this.options.endpoint) {\n          // Don't attempt to create a new upload if no endpoint is provided.\n          this._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)')\n          return\n        }\n\n        // Try to create a new upload\n        this.url = null\n        this._createUpload()\n        return\n      }\n\n      const offset = parseInt(res.getHeader('Upload-Offset'), 10)\n      if (Number.isNaN(offset)) {\n        this._emitHttpError(req, res, 'tus: invalid or missing offset value')\n        return\n      }\n\n      const length = parseInt(res.getHeader('Upload-Length'), 10)\n      if (Number.isNaN(length) && !this.options.uploadLengthDeferred) {\n        this._emitHttpError(req, res, 'tus: invalid or missing length value')\n        return\n      }\n\n      if (typeof this.options._onUploadUrlAvailable === 'function') {\n        this.options._onUploadUrlAvailable()\n      }\n\n      this._saveUploadInUrlStorage()\n        .then(() => {\n          // Upload has already been completed and we do not need to send additional\n          // data to the server\n          if (offset === length) {\n            this._emitProgress(length, length)\n            this._emitSuccess()\n            return\n          }\n\n          this._offset = offset\n          this._performUpload()\n        })\n    }).catch((err) => {\n      this._emitHttpError(req, null, 'tus: failed to resume upload', err)\n    })\n  }\n\n  /**\n   * Start uploading the file using PATCH requests. The file will be divided\n   * into chunks as specified in the chunkSize option. During the upload\n   * the onProgress event handler may be invoked multiple times.\n   *\n   * @api private\n   */\n  _performUpload () {\n    // If the upload has been aborted, we will not send the next PATCH request.\n    // This is important if the abort method was called during a callback, such\n    // as onChunkComplete or onProgress.\n    if (this._aborted) {\n      return\n    }\n\n    let req\n\n    // Some browser and servers may not support the PATCH method. For those\n    // cases, you can tell tus-js-client to use a POST request with the\n    // X-HTTP-Method-Override header for simulating a PATCH request.\n    if (this.options.overridePatchMethod) {\n      req = this._openRequest('POST', this.url)\n      req.setHeader('X-HTTP-Method-Override', 'PATCH')\n    } else {\n      req = this._openRequest('PATCH', this.url)\n    }\n\n    req.setHeader('Upload-Offset', this._offset)\n    const promise = this._addChunkToRequest(req)\n\n    promise.then((res) => {\n      if (!inStatusCategory(res.getStatus(), 200)) {\n        this._emitHttpError(req, res, 'tus: unexpected response while uploading chunk')\n        return\n      }\n\n      this._handleUploadResponse(req, res)\n    }).catch((err) => {\n      // Don't emit an error if the upload was aborted manually\n      if (this._aborted) {\n        return\n      }\n\n      this._emitHttpError(req, null, `tus: failed to upload chunk at offset ${this._offset}`, err)\n    })\n  }\n\n  /**\n   * _addChunktoRequest reads a chunk from the source and sends it using the\n   * supplied request object. It will not handle the response.\n   *\n   * @api private\n   */\n  _addChunkToRequest (req) {\n    const start = this._offset\n    let end = this._offset + this.options.chunkSize\n\n    req.setProgressHandler((bytesSent) => {\n      this._emitProgress(start + bytesSent, this._size)\n    })\n\n    req.setHeader('Content-Type', 'application/offset+octet-stream')\n\n    // The specified chunkSize may be Infinity or the calcluated end position\n    // may exceed the file's size. In both cases, we limit the end position to\n    // the input's total size for simpler calculations and correctness.\n    if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n      end = this._size\n    }\n\n    return this._source.slice(start, end)\n      .then(({ value, done }) => {\n        // If the upload length is deferred, the upload size was not specified during\n        // upload creation. So, if the file reader is done reading, we know the total\n        // upload size and can tell the tus server.\n        if (this.options.uploadLengthDeferred && done) {\n          this._size = this._offset + (value && value.size ? value.size : 0)\n          req.setHeader('Upload-Length', this._size)\n        }\n\n        if (value === null) {\n          return this._sendRequest(req)\n        }\n        this._emitProgress(this._offset, this._size)\n        return this._sendRequest(req, value)\n      })\n  }\n\n  /**\n   * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n   * and already have received a response.\n   *\n   * @api private\n   */\n  _handleUploadResponse (req, res) {\n    const offset = parseInt(res.getHeader('Upload-Offset'), 10)\n    if (Number.isNaN(offset)) {\n      this._emitHttpError(req, res, 'tus: invalid or missing offset value')\n      return\n    }\n\n    this._emitProgress(offset, this._size)\n    this._emitChunkComplete(offset - this._offset, offset, this._size)\n\n    this._offset = offset\n\n    if (offset === this._size) {\n      // Yay, finally done :)\n      this._emitSuccess()\n      this._source.close()\n      return\n    }\n\n    this._performUpload()\n  }\n\n  /**\n   * Create a new HTTP request object with the given method and URL.\n   *\n   * @api private\n   */\n  _openRequest (method, url) {\n    const req = openRequest(method, url, this.options)\n    this._req = req\n    return req\n  }\n\n  /**\n   * Remove the entry in the URL storage, if it has been saved before.\n   *\n   * @api private\n   */\n  _removeFromUrlStorage () {\n    if (!this._urlStorageKey) return\n\n    this._urlStorage.removeUpload(this._urlStorageKey).catch((err) => {\n      this._emitError(err)\n    })\n    this._urlStorageKey = null\n  }\n\n  /**\n   * Add the upload URL to the URL storage, if possible.\n   *\n   * @api private\n   */\n  _saveUploadInUrlStorage () {\n    // We do not store the upload URL\n    // - if it was disabled in the option, or\n    // - if no fingerprint was calculated for the input (i.e. a stream), or\n    // - if the URL is already stored (i.e. key is set alread).\n    if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) {\n      return Promise.resolve()\n    }\n\n    const storedUpload = {\n      size        : this._size,\n      metadata    : this.options.metadata,\n      creationTime: new Date().toString(),\n    }\n\n    if (this._parallelUploads) {\n      // Save multiple URLs if the parallelUploads option is used ...\n      storedUpload.parallelUploadUrls = this._parallelUploadUrls\n    } else {\n      // ... otherwise we just save the one available URL.\n      storedUpload.uploadUrl = this.url\n    }\n\n    return this._urlStorage.addUpload(this._fingerprint, storedUpload)\n      .then((urlStorageKey) => { this._urlStorageKey = urlStorageKey })\n  }\n\n  /**\n   * Send a request with the provided body.\n   *\n   * @api private\n   */\n  _sendRequest (req, body = null) {\n    return sendRequest(req, body, this.options)\n  }\n}\n\nfunction encodeMetadata (metadata) {\n  return Object.entries(metadata)\n    .map(([key, value]) => `${key} ${Base64.encode(String(value))}`)\n    .join(',')\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory (status, category) {\n  return (status >= category && status < (category + 100))\n}\n\n/**\n * Create a new HTTP request with the specified method and URL.\n * The necessary headers that are included in every request\n * will be added, including the request ID.\n *\n * @api private\n */\nfunction openRequest (method, url, options) {\n  const req = options.httpStack.createRequest(method, url)\n\n  req.setHeader('Tus-Resumable', '1.0.0')\n  const headers = options.headers || {}\n\n  Object.entries(headers)\n    .forEach(([name, value]) => { req.setHeader(name, value) })\n\n  if (options.addRequestId) {\n    const requestId = uuid()\n    req.setHeader('X-Request-ID', requestId)\n  }\n\n  return req\n}\n\n/**\n * Send a request with the provided body while invoking the onBeforeRequest\n * and onAfterResponse callbacks.\n *\n * @api private\n */\nfunction sendRequest (req, body, options) {\n  const onBeforeRequestPromise = (typeof options.onBeforeRequest === 'function')\n    ? Promise.resolve(options.onBeforeRequest(req))\n    : Promise.resolve()\n\n  return onBeforeRequestPromise.then(() => {\n    return req.send(body)\n      .then((res) => {\n        const onAfterResponsePromise = (typeof options.onAfterResponse === 'function')\n          ? Promise.resolve(options.onAfterResponse(req, res))\n          : Promise.resolve()\n\n        return onAfterResponsePromise.then(() => res)\n      })\n  })\n}\n\n/**\n * Checks whether the browser running this code has internet access.\n * This function will always return true in the node.js environment\n *\n * @api private\n */\nfunction isOnline () {\n  let online = true\n  if (typeof window !== 'undefined'\n        && 'navigator' in window // eslint-disable-line no-undef\n        && window.navigator.onLine === false) { // eslint-disable-line no-undef\n    online = false\n  }\n\n  return online\n}\n\n/**\n * Checks whether or not it is ok to retry a request.\n * @param {Error} err the error returned from the last request\n * @param {number} retryAttempt the number of times the request has already been retried\n * @param {object} options tus Upload options\n *\n * @api private\n */\nfunction shouldRetry (err, retryAttempt, options) {\n  // We only attempt a retry if\n  // - retryDelays option is set\n  // - we didn't exceed the maxium number of retries, yet, and\n  // - this error was caused by a request or it's response and\n  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or\n  // a onShouldRetry is specified and returns true\n  // - the browser does not indicate that we are offline\n  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {\n    return false\n  }\n\n  if (options && typeof options.onShouldRetry === 'function') {\n    return options.onShouldRetry(err, retryAttempt, options)\n  }\n\n  const status = err.originalResponse ? err.originalResponse.getStatus() : 0\n  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline()\n}\n\n/**\n * Resolve a relative link given the origin as source. For example,\n * if a HTTP request to http://example.com/files/ returns a Location\n * header with the value /upload/abc, the resolved URL will be:\n * http://example.com/upload/abc\n */\nfunction resolveUrl (origin, link) {\n  return new URL(link, origin).toString()\n}\n\n/**\n * Calculate the start and end positions for the parts if an upload\n * is split into multiple parallel requests.\n *\n * @param {number} totalSize The byte size of the upload, which will be split.\n * @param {number} partCount The number in how many parts the upload will be split.\n * @return {object[]}\n * @api private\n */\nfunction splitSizeIntoParts (totalSize, partCount) {\n  const partSize = Math.floor(totalSize / partCount)\n  const parts = []\n\n  for (let i = 0; i < partCount; i++) {\n    parts.push({\n      start: partSize * i,\n      end  : partSize * (i + 1),\n    })\n  }\n\n  parts[partCount - 1].end = totalSize\n\n  return parts\n}\n\nBaseUpload.defaultOptions = defaultOptions\n\nexport default BaseUpload\n",
    "/**\n * Generate a UUID v4 based on random numbers. We intentioanlly use the less\n * secure Math.random function here since the more secure crypto.getRandomNumbers\n * is not available on all platforms.\n * This is not a problem for us since we use the UUID only for generating a\n * request ID, so we can correlate server logs to client errors.\n *\n * This function is taken from following site:\n * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n *\n * @return {string} The generate UUID\n */\nexport default function uuid () {\n  /* eslint-disable no-bitwise */\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0\n    const v = c === 'x' ? r : ((r & 0x3) | 0x8)\n    return v.toString(16)\n  })\n}\n",
    "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n",
    "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n",
    "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n",
    "//\n// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!\n//\n;\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined'\n        ? module.exports = factory()\n        : typeof define === 'function' && define.amd\n            ? define(factory) :\n            // cf. https://github.com/dankogai/js-base64/issues/119\n            (function () {\n                // existing version for noConflict()\n                var _Base64 = global.Base64;\n                var gBase64 = factory();\n                gBase64.noConflict = function () {\n                    global.Base64 = _Base64;\n                    return gBase64;\n                };\n                if (global.Meteor) { // Meteor.js\n                    Base64 = gBase64;\n                }\n                global.Base64 = gBase64;\n            })();\n}((typeof self !== 'undefined' ? self\n    : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n            : this), function () {\n    'use strict';\n    /**\n     *  base64.ts\n     *\n     *  Licensed under the BSD 3-Clause License.\n     *    http://opensource.org/licenses/BSD-3-Clause\n     *\n     *  References:\n     *    http://en.wikipedia.org/wiki/Base64\n     *\n     * @author Dan Kogai (https://github.com/dankogai)\n     */\n    var version = '3.7.2';\n    /**\n     * @deprecated use lowercase `version`.\n     */\n    var VERSION = version;\n    var _hasatob = typeof atob === 'function';\n    var _hasbtoa = typeof btoa === 'function';\n    var _hasBuffer = typeof Buffer === 'function';\n    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\n    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\n    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var b64chs = Array.prototype.slice.call(b64ch);\n    var b64tab = (function (a) {\n        var tab = {};\n        a.forEach(function (c, i) { return tab[c] = i; });\n        return tab;\n    })(b64chs);\n    var b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    var _fromCC = String.fromCharCode.bind(String);\n    var _U8Afrom = typeof Uint8Array.from === 'function'\n        ? Uint8Array.from.bind(Uint8Array)\n        : function (it, fn) {\n            if (fn === void 0) { fn = function (x) { return x; }; }\n            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\n        };\n    var _mkUriSafe = function (src) { return src\n        .replace(/=/g, '').replace(/[+\\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };\n    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\\+\\/]/g, ''); };\n    /**\n     * polyfill version of `btoa`\n     */\n    var btoaPolyfill = function (bin) {\n        // console.log('polyfilled');\n        var u32, c0, c1, c2, asc = '';\n        var pad = bin.length % 3;\n        for (var i = 0; i < bin.length;) {\n            if ((c0 = bin.charCodeAt(i++)) > 255 ||\n                (c1 = bin.charCodeAt(i++)) > 255 ||\n                (c2 = bin.charCodeAt(i++)) > 255)\n                throw new TypeError('invalid character found');\n            u32 = (c0 << 16) | (c1 << 8) | c2;\n            asc += b64chs[u32 >> 18 & 63]\n                + b64chs[u32 >> 12 & 63]\n                + b64chs[u32 >> 6 & 63]\n                + b64chs[u32 & 63];\n        }\n        return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n    };\n    /**\n     * does what `window.btoa` of web browsers do.\n     * @param {String} bin binary string\n     * @returns {string} Base64-encoded string\n     */\n    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }\n        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }\n            : btoaPolyfill;\n    var _fromUint8Array = _hasBuffer\n        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }\n        : function (u8a) {\n            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n            var maxargs = 0x1000;\n            var strs = [];\n            for (var i = 0, l = u8a.length; i < l; i += maxargs) {\n                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n            }\n            return _btoa(strs.join(''));\n        };\n    /**\n     * converts a Uint8Array to a Base64 string.\n     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n     * @returns {string} Base64 string\n     */\n    var fromUint8Array = function (u8a, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n    };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const utob = (src: string) => unescape(encodeURIComponent(src));\n    // reverting good old fationed regexp\n    var cb_utob = function (c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                    + _fromCC(0x80 | (cc & 0x3f)))\n                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                        + _fromCC(0x80 | (cc & 0x3f)));\n        }\n        else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                + _fromCC(0x80 | (cc & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-8 string\n     * @returns {string} UTF-16 string\n     */\n    var utob = function (u) { return u.replace(re_utob, cb_utob); };\n    //\n    var _encode = _hasBuffer\n        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }\n        : _TE\n            ? function (s) { return _fromUint8Array(_TE.encode(s)); }\n            : function (s) { return _btoa(utob(s)); };\n    /**\n     * converts a UTF-8-encoded string to a Base64 string.\n     * @param {boolean} [urlsafe] if `true` make the result URL-safe\n     * @returns {string} Base64 string\n     */\n    var encode = function (src, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe\n            ? _mkUriSafe(_encode(src))\n            : _encode(src);\n    };\n    /**\n     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n     * @returns {string} Base64 string\n     */\n    var encodeURI = function (src) { return encode(src, true); };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const btou = (src: string) => decodeURIComponent(escape(src));\n    // reverting good old fationed regexp\n    var re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n    var cb_btou = function (cccc) {\n        switch (cccc.length) {\n            case 4:\n                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                    | ((0x3f & cccc.charCodeAt(1)) << 12)\n                    | ((0x3f & cccc.charCodeAt(2)) << 6)\n                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n                return (_fromCC((offset >>> 10) + 0xD800)\n                    + _fromCC((offset & 0x3FF) + 0xDC00));\n            case 3:\n                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    | (0x3f & cccc.charCodeAt(2)));\n            default:\n                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                    | (0x3f & cccc.charCodeAt(1)));\n        }\n    };\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-16 string\n     * @returns {string} UTF-8 string\n     */\n    var btou = function (b) { return b.replace(re_btou, cb_btou); };\n    /**\n     * polyfill version of `atob`\n     */\n    var atobPolyfill = function (asc) {\n        // console.log('polyfilled');\n        asc = asc.replace(/\\s+/g, '');\n        if (!b64re.test(asc))\n            throw new TypeError('malformed base64.');\n        asc += '=='.slice(2 - (asc.length & 3));\n        var u24, bin = '', r1, r2;\n        for (var i = 0; i < asc.length;) {\n            u24 = b64tab[asc.charAt(i++)] << 18\n                | b64tab[asc.charAt(i++)] << 12\n                | (r1 = b64tab[asc.charAt(i++)]) << 6\n                | (r2 = b64tab[asc.charAt(i++)]);\n            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n        }\n        return bin;\n    };\n    /**\n     * does what `window.atob` of web browsers do.\n     * @param {String} asc Base64-encoded string\n     * @returns {string} binary string\n     */\n    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }\n        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }\n            : atobPolyfill;\n    //\n    var _toUint8Array = _hasBuffer\n        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }\n        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };\n    /**\n     * converts a Base64 string to a Uint8Array.\n     */\n    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };\n    //\n    var _decode = _hasBuffer\n        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }\n        : _TD\n            ? function (a) { return _TD.decode(_toUint8Array(a)); }\n            : function (a) { return btou(_atob(a)); };\n    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };\n    /**\n     * converts a Base64 string to a UTF-8 string.\n     * @param {String} src Base64 string.  Both normal and URL-safe are supported\n     * @returns {string} UTF-8 string\n     */\n    var decode = function (src) { return _decode(_unURI(src)); };\n    /**\n     * check if a value is a valid Base64 string\n     * @param {String} src a value to check\n      */\n    var isValid = function (src) {\n        if (typeof src !== 'string')\n            return false;\n        var s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n        return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n    };\n    //\n    var _noEnum = function (v) {\n        return {\n            value: v, enumerable: false, writable: true, configurable: true\n        };\n    };\n    /**\n     * extend String.prototype with relevant methods\n     */\n    var extendString = function () {\n        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };\n        _add('fromBase64', function () { return decode(this); });\n        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n        _add('toBase64URI', function () { return encode(this, true); });\n        _add('toBase64URL', function () { return encode(this, true); });\n        _add('toUint8Array', function () { return toUint8Array(this); });\n    };\n    /**\n     * extend Uint8Array.prototype with relevant methods\n     */\n    var extendUint8Array = function () {\n        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };\n        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n        _add('toBase64URI', function () { return fromUint8Array(this, true); });\n        _add('toBase64URL', function () { return fromUint8Array(this, true); });\n    };\n    /**\n     * extend Builtin prototypes with relevant methods\n     */\n    var extendBuiltins = function () {\n        extendString();\n        extendUint8Array();\n    };\n    var gBase64 = {\n        version: version,\n        VERSION: VERSION,\n        atob: _atob,\n        atobPolyfill: atobPolyfill,\n        btoa: _btoa,\n        btoaPolyfill: btoaPolyfill,\n        fromBase64: decode,\n        toBase64: encode,\n        encode: encode,\n        encodeURI: encodeURI,\n        encodeURL: encodeURI,\n        utob: utob,\n        btou: btou,\n        decode: decode,\n        isValid: isValid,\n        fromUint8Array: fromUint8Array,\n        toUint8Array: toUint8Array,\n        extendString: extendString,\n        extendUint8Array: extendUint8Array,\n        extendBuiltins: extendBuiltins\n    };\n    //\n    // export Base64 to the namespace\n    //\n    // ES5 is yet to have Object.assign() that may make transpilers unhappy.\n    // gBase64.Base64 = Object.assign({}, gBase64);\n    gBase64.Base64 = {};\n    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });\n    return gBase64;\n}));\n",
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n",
    "'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n",
    "'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/\n  , CRHTLF = /[\\n\\r\\t]/g\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , port = /:\\d+$/\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n  , windowsDriveLetter = /^[a-zA-Z]:/;\n\n/**\n * Remove control characters and whitespace from the beginning of a string.\n *\n * @param {Object|String} str String to trim.\n * @returns {String} A new string representing `str` stripped of control\n *     characters and whitespace from its beginning.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(controlOrWhitespace, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof global !== 'undefined') globalVar = global;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4]\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@'\n        ? address.lastIndexOf(parse)\n        : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password))\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username +':'+ url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (port.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.auth = url.password ? url.username +':'+ url.password : url.username;\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , host = url.host\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result =\n    protocol +\n    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  } else if (url.password) {\n    result += ':'+ url.password;\n    result += '@';\n  } else if (\n    url.protocol !== 'file:' &&\n    isSpecial(url.protocol) &&\n    !host &&\n    url.pathname !== '/'\n  ) {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  }\n\n  //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {\n    host += ':';\n  }\n\n  result += host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n"
  ]
}